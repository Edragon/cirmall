/*************************************************************************
 - 功能描述： 串口发送一个字节
 - 隶属模块： 外部
 - 参数说明：
 - 返回说明：
 - 注：	 
1、每种芯片的串口输出的方式不一样，这里是我们自己的芯片的方式
2、您也只用修改这个接口封装一下即可
*************************************************************************/

void func_send_byte( u8 dat )
{
    ctrl_uart_write(dat) ;/*替换这个接口*/
}

/*************************************************************************
 - 功能描述： 串口发送字符串
 - 隶属模块： 外部
 - 参数说明：
 - 返回说明：
 - 注：	 
*************************************************************************/
void func_UartPutStr (const char *Str )
{
    while ( *Str)
    {
        func_send_byte ( *Str );
        *Str++;
    }
}

/*************************************************************************
 - 功能描述： 串口接收处理 --- 参考
 - 隶属模块： 外部
 - 参数说明：
 - 返回说明：
 - 注：	 
1、串口接收都是采用中断的方式，一定要设置一个超时的计数器，超时做错误处理
2、由于我们所有的命令都是以0x0D和0x0A作为结束，所以只用检测0x0A就认为接收完成
*************************************************************************/

void uart_isr_recv(u8 uto_buf)
{
    g_uart_flag.uart_timeout = UART_TIMEOUT ;/*一般100ms*/
    g_uart_flag.uart_stop  = 0; 
    buf_uart1.buf[buf_uart1.index++] = uto_buf;/*字符存到缓存中*/
    if(uto_buf == 0x0A)               /*收到数据0x0A则认为一帧数据结束了*/
    {
        g_uart_flag.uart_stop  = 1;   /*接收完成标志位置1*/
        g_uart_flag.uart_analysis = 1;/*分析数据使能打开*/          
        g_uart_flag.uart_timeout = 0 ;
        uart_recv_ok_pro(buf_uart1.buf ,buf_uart1.index) ;  /*这里就是接收完成之后的处理*/
        
        /*这里添加你自己的应用程序*/
    }
}


/*************************************************************************
 - 功能描述： main
 - 隶属模块： 外部
 - 参数说明：
 - 返回说明：
 - 注：	 
*************************************************************************/
void main()
{
    uart_init() ;/*串口初始化*/
    delay_2ms(500) ;/*延时1秒*/
	func_UartPutStr("AT+CA30\r\n") ;/*设置音量为30级*/
    delay_2ms(500) ;/*延时1秒*/
	func_UartPutStr("AT+CA15\r\n") ;/*设置音量为15级*/
    delay_2ms(500) ;/*延时1秒*/
	func_UartPutStr("AT+BD12354678\r\n") ;/*设置蓝牙名为12345678*/
    delay_2ms(500) ;/*延时1秒*/
	func_UartPutStr("AT+CT02\r\n") ;/*设置波特率为19200 -- 参考手册*/
    delay_2ms(500) ;/*延时1秒*/

    while(1) ;
}